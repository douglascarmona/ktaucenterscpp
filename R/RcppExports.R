# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Returns each observation's cluster location based on the euclidean distance
#' between the observation and cluster centers.
#'
#' @param x a numeric matrix with observations.
#' @param centers a numeric matrix with observations with cluster's centers
#' coordinates.
#'
#' @return A list with the following components:
#' \item{clusters }{a vector indicating each point observation's cluster. }
#' \item{distance }{a vector with the distance from each
#' observation to its corresponding cluster center. }
#'
cluster_location <- function(x, centers) {
    .Call('_ktaucenterscpp_cluster_location', PACKAGE = 'ktaucenterscpp', x, centers)
}

#' Counts the number of observations per cluster
#'
#' @param cluster_location a vector with positive intergers containing each
#' point observation's cluster.
#' @param n_clusters total number of clusters
#'
#' @return
#' Vector with number of observations per cluster
#'
cluster_counter <- function(cluster_location, n_clusters) {
    .Call('_ktaucenterscpp_cluster_counter', PACKAGE = 'ktaucenterscpp', cluster_location, n_clusters)
}

#' Distance Matrix Computation
#'
#' Computes and returns the distance matrix using euclidean distance
#' measure to compute the distances between the rows of a
#' data matrix.
#'
#' @param x a numeric matrix.
#'
#' @return
#' A numeric matrix with the distances between the rows of a matrix.
#'
distance <- function(x) {
    .Call('_ktaucenterscpp_distance', PACKAGE = 'ktaucenterscpp', x)
}

#' Find the k Nearest Neighbors
#'
#' \strong{Ties}: If the kth and the (k+1)th nearest neighbor are tied, then
#' the neighbor found first is returned and the other one is ignored.
#'
#' @param D a distance matrix, which contains the distances between the rows of
#' a matrix.
#' @param k number of neighbors to find.
#'
#' @return A list with the following components:
#' \item{dist }{a matrix with distances. }
#' \item{id }{a matrix with indices of the k nearest neighbors. }
#' \item{k }{number neighbors used. }
#'
dist_to_kNN <- function(D, k) {
    .Call('_ktaucenterscpp_dist_to_kNN', PACKAGE = 'ktaucenterscpp', D, k)
}

#'
#'@export
ktaucenters_run <- function(x, centers, tolerance, iter_max, method) {
    .Call('_ktaucenterscpp_ktaucenters_run', PACKAGE = 'ktaucenterscpp', x, centers, tolerance, iter_max, method)
}

#' Quasi optimal rho function
#'
#' @param x numeric vector with positive values.
#' @param c tunning constant.
#'
#' @return
#' Numeric vector with quasi optimal rho computation for each element of
#' x.
#'
#'@references
#' [1] Salibian-Barrera, M., Willems, G., & Zamar, R. (2008). The fast-tau
#' estimator for regression. Journal of Computational and GraphicalStatistics,
#' 17(3), 659-682.
#'
rho_opt <- function(x, c) {
    .Call('_ktaucenterscpp_rho_opt', PACKAGE = 'ktaucenterscpp', x, c)
}

#' Derivative of the quasi optimal rho function
#'
#' @param x numeric vector with positive values.
#' @param c tunning constant.
#'
#' @return
#' Numeric vector with the derivative of the quasi optimal rho computation
#' for each element of x.
#'
psi_opt <- function(x, c) {
    .Call('_ktaucenterscpp_psi_opt', PACKAGE = 'ktaucenterscpp', x, c)
}

#' Second derivative of the quasi rho function
#'
#' @param x numeric vector with positive values.
#' @param c tunning constant.
#'
#' @return
#' Numeric vector with the second derivative of the quasi optimal rho
#' computation for each element of x.
#'
derpsi_opt <- function(x, c) {
    .Call('_ktaucenterscpp_derpsi_opt', PACKAGE = 'ktaucenterscpp', x, c)
}

#' Estimates the local points density.
#'
#' @param D a distance matrix, which contains the distances between the rows of
#' a matrix.
#' @param k number of neighbors to calculate local point density.
#'
#' @return
#' A vector containing the density values for each point.
#'
point_density <- function(D, k) {
    .Call('_ktaucenterscpp_point_density', PACKAGE = 'ktaucenterscpp', D, k)
}

#' Utility function to estimate robinden center
#'
#' @param idp a vector with containing the inverse density each point.
#' @param indices vector with sorted indices.
#' @param crit_robin critical robin value.
#'
#' @return
#' Index of the cluster center
#'
robin_center <- function(idp, indices, crit_robin) {
    .Call('_ktaucenterscpp_robin_center', PACKAGE = 'ktaucenterscpp', idp, indices, crit_robin)
}

#' Robust Initialization based on Inverse Density estimator (ROBINDEN)
#'
#' Searches for k initial cluster seeds for k-means based clustering methods.
#'
#' @param D a distance matrix, which contains the distances between the rows of
#' a matrix.
#' @param n_clusters number of cluster centers to find.
#' @param mp number of nearest neighbors to compute point density
#'
#' @return A list with the following components:
#' \item{centers }{A numeric vector with the initial cluster centers indices}
#' \item{idpoints }{A real vector containing the inverse of point density
#' estimation}
#'
#' @details
#' The centers are the observations located in the most dense region
#' and far away from each other at the same time.
#' In order to find the observations in the highly dense region, this function
#' uses point density estimation (instead of Local Outlier Factor, Breunig et
#' al (2000)), see more details.
#'
#' @note This is a slightly modified version of ROBIN algorithm
#' implementation done by Sarka Brodinova <sarka.brodinova@tuwien.ac.at>.
#' @author Juan Domingo Gonzalez <juanrst@hotmail.com>
#'
#' @references Hasan AM, et al. Robust partitional clustering by
#' outlier and density insensitive seeding. Pattern Recognition Letters,
#' 30(11), 994-1002, 2009.
#'
#'@export
robinden <- function(D, n_clusters, mp) {
    .Call('_ktaucenterscpp_robinden', PACKAGE = 'ktaucenterscpp', D, n_clusters, mp)
}

#' Normal Consistency Constants
#'
#' M scale tuning constants so it is consistent with the standard
#' normal distribution for the quasi optimal \eqn{\rho} function used in
#' \code{\link{rho_opt}}. These constants were computed for 1 \eqn{\leq} p
#' \eqn{\leq} 400.
#'
#' @param p dimension where observation lives.
#'
#' @return tuning constant.
#'
#' @references
#' [1] Maronna, R. A., Martin, R. D., Yohai, V. J., & Salibián-Barrera, M.
#' (2018). 'Robust statistics: theory and methods (with ' R). Wiley.
#'
#' [2] Salibian-Barrera, M., Willems, G., & Zamar, R. (2008). The fast-tau
#' estimator for regression. 'Journal of Computational and Graphical
#' Statistics, 17(3), 659-682.
#'
normal_consistency_constants <- function(p) {
    .Call('_ktaucenterscpp_normal_consistency_constants', PACKAGE = 'ktaucenterscpp', p)
}

#' Tuning constant for \eqn{\tau}-estimator
#'
#' Tuning constant approximation for \eqn{\tau}-estimator to reach 90%
#' efficiency
#'
#' @param p dimension where observation lives.
#'
#' @return
#' Tuning constant for \eqn{\tau}-estimator.
#'
#' @references
#' Maronna, R. A. and Yohai, V. J. (2017). Robust and efficient estimation of
#' multivariate scatter and location. Computational Statistics & Data Analysis,
#' 109:64–75.
#'
const_c2 <- function(p) {
    .Call('_ktaucenterscpp_const_c2', PACKAGE = 'ktaucenterscpp', p)
}

#' M scale
#'
#' The M scale of an univariate sample.
#'
#' @param u numeric vector with positive values.
#' @param c a tuning constant. If consistency to standard normal distribution
#' is desired use \code{\link{normal_consistency_constants}}
#' @param b the desired break down point.
#'
#' @return
#' M scale value
#'
mscale <- function(u, c, b) {
    .Call('_ktaucenterscpp_mscale', PACKAGE = 'ktaucenterscpp', u, c, b)
}

#' \eqn{\tau} scale
#'
#' The \eqn{\tau} scale of an univariate sample.
#'
#' @param u numeric vector with positive values.
#' @param s M scale for the same univariate sample (u).
#' @param c tuning constant to regulate estimator's efficiency.
#'
#' @return
#' \eqn{\tau} scale value
#'
tau_scale <- function(u, c, s) {
    .Call('_ktaucenterscpp_tau_scale', PACKAGE = 'ktaucenterscpp', u, c, s)
}

#' Weight function
#'
#' @param distances numeric vector with distances from each point to its
#' cluster center.
#' @param c1 tuning constant used for m scale estimation.
#' @param c2 tuning constant used for \eqn{\tau} scale estimation.
#' @param s M scale for the same vector of distances.
#'
#' @return
#' Numeric vector with the weight for each observation
#'
wni <- function(distances, c1, c2, s) {
    .Call('_ktaucenterscpp_wni', PACKAGE = 'ktaucenterscpp', distances, c1, c2, s)
}

#' Weight factor
#'
#' @param wni numeric vector with the weight for each observation.
#' @param clusters integer vector with the cluster location for each
#' observation.
#'
#' @return
#' Numeric vector with the weight factor for each observation
#'
weight_factor <- function(wni, clusters) {
    .Call('_ktaucenterscpp_weight_factor', PACKAGE = 'ktaucenterscpp', wni, clusters)
}

#' Computes new cluster centers
#'
#' @param x numeric matrix of size n x p with all observations.
#' @param weights numeric vector of size n with the weight factor for each
#' observation.
#' @param clusters integer vector of size n with the cluster location for each
#' observation.
#' @param distances numeric vector of size n with the distances from each
#' observation to its nearest cluster center.
#'
#' @return
#' Numeric matrix with the new cluster centers.
#'
new_centers <- function(x, weights, clusters, distances) {
    .Call('_ktaucenterscpp_new_centers', PACKAGE = 'ktaucenterscpp', x, weights, clusters, distances)
}

#' Calculates the median of a numeric vector
median_cpp <- function(x) {
    .Call('_ktaucenterscpp_median_cpp', PACKAGE = 'ktaucenterscpp', x)
}

#' Find the first nth indices from a vector
#'
#' @param v a numeric vector from which indices are found.
#' @param n number of indices to find.
#' @param decreasing boolean value indicating if the vector must be in
#' decreasing order
#'
#' @return
#' A vector with first nth indices.
#'
top_index <- function(v, n, decreasing) {
    .Call('_ktaucenterscpp_top_index', PACKAGE = 'ktaucenterscpp', v, n, decreasing)
}

#' Estimates maximum tolerance between two given matrix row wise
#'
max_tolerance <- function(x, y) {
    .Call('_ktaucenterscpp_max_tolerance', PACKAGE = 'ktaucenterscpp', x, y)
}

